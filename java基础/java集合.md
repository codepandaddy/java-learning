



## 集合

### HashMap

#### 为什么由数组和链表组成

- 数组中key-value实例，在java7中叫Entry，java8叫node
- 数组长度有限，哈希本身有概率性，map.put两次，计算两个哈希有可能相等，那就只能用链表来表示
  - 每个node都会保留自身的hash,key,value以及下一个节点
  - ![屏幕截图 2023-04-16 203827](D:\1deptTrain\manifestOfThreeMonth\屏幕截图 2023-04-16 203827.png)
  - next表示下一个hash相同的元素

#### 为什么hashmap的数组初始化大小都是2的次方newCapacity <<= 1;

- hash值是通过hashcode与16异或运算出来的，使得hash值更加均匀
- 比如 数组长度为15时（非2的倍数）
  - hashcode的值会与14（1110）进行“与”，那么最后一位永远是0，而0001，0011，0101，1001，1011，0111，1101这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率
  - hashcode为8和9时，但是很明显，当它们和1110“与”的时候，产生了相同的结果，也就是说它们会定位到数组中的同一个位置上去，这就产生了碰撞，8和9会被放到同一个链表上，那么查询的时候就需要遍历这个链表，得到8或者9，这样就降低了查询的效率
- 所以说，当数组长度为2的n次幂的时候，不同的key算得得index相同的几率较小，那么数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了
- 扩容过程
  - 创建一个新的Entry空数组，长度是原数组的2倍，遍历原Entry数组，重新hash到新数组上
    - 重新hash而不复制的原因是因为，hash规则也改变
    - index = HashCode(Key) & (Length - 1)
    - 长度不同计算hash的规则也不同

#### 为什么要重写hashCode和equals

- HashMap继承Object的方法，equals比较对象地址，肯定是不一样的
- hashmap是通过key的hashCode去找index，有可能出现index相同的情况，所以要对equals重写，保证相同对象返回相同hash值，不同对象返回不同hash值